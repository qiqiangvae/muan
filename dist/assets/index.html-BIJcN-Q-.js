import{_ as n,c as s,b as i,o as h}from"./app-C-1nbDAo.js";const e={};function p(r,a){return h(),s("div",null,a[0]||(a[0]=[i('<h2 id="操作系统概述" tabindex="-1"><a class="header-anchor" href="#操作系统概述"><span>操作系统概述</span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>能有效地组织和管理系统中的各种软硬件资源，合理地组织计算机系统工作流程，控制流程的执行，并且向用户提供一个良好的工作环境和友好的接口。</p><h3 id="三个作用" tabindex="-1"><a class="header-anchor" href="#三个作用"><span>三个作用</span></a></h3><ol><li>管理计算机中运行的程序和分配各种软硬件资源；</li><li>为用户提供友善的人机界面；</li><li>为应用程序的开发和运行提供一个高效率的平台；</li></ol><h3 id="四个特征" tabindex="-1"><a class="header-anchor" href="#四个特征"><span>四个特征</span></a></h3><ol><li>并发性；</li><li>共享性；</li><li>虚拟性；</li><li>不确定性（异步性）；</li></ol><h3 id="操作系统的分类" tabindex="-1"><a class="header-anchor" href="#操作系统的分类"><span>操作系统的分类</span></a></h3><h4 id="批处理操作系统" tabindex="-1"><a class="header-anchor" href="#批处理操作系统"><span>批处理操作系统</span></a></h4><p>批处理操作系统分为单道批处理和多道批处理。</p><h4 id="分时操作系统" tabindex="-1"><a class="header-anchor" href="#分时操作系统"><span>分时操作系统</span></a></h4><p>分时操作系统是将 CPU 的工作时间划分为许多很短的时间片，轮流为各个终端的用户服务。尽管各个终端商的作业是断续运行的，但是由于操作系统每次对用户程序都能做出及时响应，因此用户感觉整个系统均归一人占用。分时操作系统的四个特性，多路性、独立性、交互性和及时性。</p><h4 id="实时操作系统" tabindex="-1"><a class="header-anchor" href="#实时操作系统"><span>实时操作系统</span></a></h4><p>实时是指计算机对于外来信息能够以足够快的速度进行处理，并在被控对象允许的时间范围内做出快速反应。实时系统对交互能力要求不高，但要求可靠性有保障。</p><h4 id="网络操作系统" tabindex="-1"><a class="header-anchor" href="#网络操作系统"><span>网络操作系统</span></a></h4><p>网络操作系统是使联网计算机能够方便而有效地共享网络资源，为网络用户提供各种服务的软件和有关协议的集合。一个典型的网络操作系统的特征包括硬件独立性和多用户支持等。</p><h4 id="分布式操作系统" tabindex="-1"><a class="header-anchor" href="#分布式操作系统"><span>分布式操作系统</span></a></h4><p>分布式操作系统是由多个分散的计算机连接而成的计算机系统，系统中的计算机无主次之分。分布式操作系统是网络操作系统的更高级形式，它保持网络系统所拥有的全部功能，同时又有透明性、可靠性和高性能等特性。</p><h4 id="微型计算机操作系统" tabindex="-1"><a class="header-anchor" href="#微型计算机操作系统"><span>微型计算机操作系统</span></a></h4><p>微型计算机系统建成微机操作系统，如 Windows、Mac OS、Linux 等。</p><h4 id="嵌入式操作系统" tabindex="-1"><a class="header-anchor" href="#嵌入式操作系统"><span>嵌入式操作系统</span></a></h4><p>嵌入式操作系统的主要特点：</p><ol><li>微型化。</li><li>可定制。</li><li>实时性。</li><li>可靠性。</li><li>易移植性。</li></ol><p>嵌入式系统初始化过程按照自底向上、从硬件到软件的次序为：片级初始化 -&gt; 板级初始化 -&gt; 系统初始化。</p><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理"><span>进程管理</span></a></h2><p>进程由进程控制块 PCB（唯一标志）、程序（描述程序要做什么）和数据（存放进程执行时所需要的数据）组成。</p><h3 id="进程的三态图和五态图" tabindex="-1"><a class="header-anchor" href="#进程的三态图和五态图"><span>进程的三态图和五态图</span></a></h3><p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/Ky1IoS.png" alt="Ky1IoS"></p><h3 id="进程前驱图" tabindex="-1"><a class="header-anchor" href="#进程前驱图"><span>进程前驱图</span></a></h3><p>反应了程序之间的并行和顺序关系。</p><p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/6n7yvM.png" alt="6n7yvM"></p><h3 id="进程资源图" tabindex="-1"><a class="header-anchor" href="#进程资源图"><span>进程资源图</span></a></h3><p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/sF7hVa.png" alt="sF7hVa"></p><p>如上图所示，</p><ol><li>资源 R1 总共有两个，资源 R2 总共有三个，资源 R3 总共有两个（看有几个圆圈）。</li><li>进程 P1 拥有 1 个 R1 和 1 个 R2（看指向 P1 的箭头），还需要申请 1 个 R2（看从 P1 出去的箭头）；进程 P2 拥有 1 个 R2 和 1 个 R3，还需要申请 1 个 R1；进程P3拥有 1 个 R1 和一个 R2，还需申请 1 个 R3）。</li><li>资源 R1 还剩 0 个，R2 还剩 0 个，R3 还剩 1 个。</li><li>因为 P1 需要申请 R2，R2 无剩余，所以 P1 阻塞；因为 P2 需要申请 R1，R1 无剩余，所以 P2 阻塞；因为 P3 需要申请 R3，R3 还剩一个，所以 R3 非阻塞。</li><li>所以 P3 可以顺利执行，当 P3 执行完成后，释放 R1 和 R2，此时 P1 和 P2 都可以申请到需要的资源，那么 P1 和 P2 都可以正常执行完成。</li><li>如果所有的进程都是阻塞状态，那么此时发生死锁。</li></ol><h3 id="同步与互斥" tabindex="-1"><a class="header-anchor" href="#同步与互斥"><span>同步与互斥</span></a></h3><p>几个概念：</p><ul><li><strong>临界资源</strong>：各进程之间需要以互斥方式对其进行访问的资源；</li><li><strong>临界区</strong>：指进程中对临界资源实施操作的程序。本质是一段代码；</li><li><strong>互斥</strong>：某临界资源在同一时间内只能由一个任务单独使用，使用时加锁，使用后释放锁；</li><li><strong>同步</strong>：多个任务本身可以并发执行，但是执行速度有差异，所以会有等待，不存在资源是否单独或者共享的问题；</li><li><strong>互斥信号量</strong>：对临界资源采用互斥访问，使用互斥信号量后其它进程无法进行访问，初始值为 1；</li><li><strong>同步信号量</strong>：对共享的资源进行访问控制，初始值一般是共享资源的数量；</li></ul><h4 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量"><span>信号量</span></a></h4><p><strong>P 操作</strong>，申请资源（S=S-1），如果 S&lt;0，说明当前进程没有资源可以获取，需要阻塞；</p><p><strong>V 操作</strong>，释放资源（S=S+1），如果 S&lt;0，说明当前还有<code>|S|</code>（S的绝对值）个进程在等待资源释放，如果 S&gt;0，说明当前有 S 个资源处于空闲状态；</p><p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/4zxrVH.png" alt="4zxrVH"></p><h4 id="生产者消费者问题" tabindex="-1"><a class="header-anchor" href="#生产者消费者问题"><span>生产者消费者问题</span></a></h4><p>三个信号量：互斥信号量 S0（仓库独立使用权），同步信号量 S1（仓库空闲位置个数），同步信号量 S2（仓库商品个数）</p><p>生产者流程：生产一个商品 -&gt; P(S0) 获取仓库使用权 -&gt; P(S1) 申请一个空闲位置 -&gt; V(S2)仓库商品个数增加一个 -&gt; V(S0) 释放仓库使用权</p><p>消费者流程：P(S0) 申请使用仓库 -&gt; P(S2) 申请一个商品 -&gt; 取出一个商品 -&gt; V(S1) 仓库空闲出一个位置 -&gt; V(S0) 释放仓库使用权</p><h3 id="进程调度" tabindex="-1"><a class="header-anchor" href="#进程调度"><span>进程调度</span></a></h3><p>进程调度方式是指当有更高优先级的进程来到时如何分配 CPU。分为可剥夺和不可剥夺两种。</p><p>可剥夺指当有更高优先级的进程来到时，强行将正在运行中的进程的 CPU 分配给高优先级的进程；不可剥夺指就算高优先级的进程来到时，也需要等待当前进程完处理后自动释放 CPU。</p><h4 id="三级调度" tabindex="-1"><a class="header-anchor" href="#三级调度"><span>三级调度</span></a></h4><p>在某些操作系统中，一个作业从提交到完成需要经历高、中、低三级调度。</p><ol><li>高级调度。高级调度又称<strong>长调度</strong>、<strong>作业调度</strong>或<strong>接纳调度</strong>，它决定处于输入池中的哪个后背作业可以调入主系统做好运行准备，成为一个或一组就绪进程。在系统中一个作业调度只需要经历一次高级调度。</li><li>中级调度。又称<strong>中程调度</strong>或<strong>对换调度</strong>，它决定处于交换区中的哪个就绪进程可以调入内存，以便直接参与对 CPU 的竞争。</li><li>低级调度。又称<strong>短程调度</strong>或<strong>进程调度</strong>，它决定处于内存中的哪个就绪进程可以调入 CPU。低级调度是操作系统中最活跃、最重要的调度程序，对系统影响很大。</li></ol><h4 id="调度算法" tabindex="-1"><a class="header-anchor" href="#调度算法"><span>调度算法</span></a></h4><ul><li>先来先服务 FCFS：先来的进程优先分配 CPU；</li><li>时间片轮转：每个进程分配相同的 CPU 时间片，用于微观调度，很公平；</li><li>优先级调度：每个进程都有一个优先级，优先级大的先分配 CPU。</li><li>多级反馈调度：按优先级分成多个队列，每个队列里的进程分配相同的 CPU 时间片，优先级高的队列里的进程分配的 CPU 时间片较长；</li></ul><h3 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁"><span>死锁</span></a></h3><h4 id="发生死锁的必要条件" tabindex="-1"><a class="header-anchor" href="#发生死锁的必要条件"><span>发生死锁的必要条件</span></a></h4><p>资源互斥、每个进程占有资源并等待其他资源，系统不能剥夺进程的资源，进程资源图是一个环路。</p><h4 id="打破死锁的方法" tabindex="-1"><a class="header-anchor" href="#打破死锁的方法"><span>打破死锁的方法</span></a></h4><ol><li>死锁预防。</li><li>死锁避免。</li><li>死锁检测。</li><li>死锁解除。</li></ol><h4 id="死锁资源计算" tabindex="-1"><a class="header-anchor" href="#死锁资源计算"><span>死锁资源计算</span></a></h4><p>系统内有 n 个进程，每个进程都需要 R 个资源，那么发生死锁的最大资源数为<code>n*(R-1)</code>，不会发生死锁的最小资源数为<code>n*(R-1)+1</code>。</p><h3 id="线程" tabindex="-1"><a class="header-anchor" href="#线程"><span>线程</span></a></h3><p>进程有两个属性：可拥有资源的独立单位；可独立调度和分配的基本单位。</p><h4 id="为什么要引入线程" tabindex="-1"><a class="header-anchor" href="#为什么要引入线程"><span>为什么要引入线程</span></a></h4><p>进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，所以进程的数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。</p><p>引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。</p><p>线程是进程中的一个实体，是被系统独立分配和调度的基本单位。线程只拥有运行中必不可少的一些资源，如程序计数器、一组寄存器和栈，它与同属于一个进程的其它线程共享进程的全部资源。（进程之间的数据是相互隔离的，线程独享的资源也是隔离的）。</p><h2 id="存储管理" tabindex="-1"><a class="header-anchor" href="#存储管理"><span>存储管理</span></a></h2><h3 id="分区存储管理" tabindex="-1"><a class="header-anchor" href="#分区存储管理"><span>分区存储管理</span></a></h3><p>整存是将某进程所需要的内存整体分配，有三种分区方式：</p><h4 id="固定分区" tabindex="-1"><a class="header-anchor" href="#固定分区"><span>固定分区</span></a></h4><p>这是一种静态分区方法。将主存分为若干个固定的分区，将要运行的作业装配进去。由于分区大小固定，就可能和作业需要的大小不同，从而浪费一些空间，产生内部碎片。</p><h4 id="可变分区" tabindex="-1"><a class="header-anchor" href="#可变分区"><span>可变分区</span></a></h4><p>这是一种动态分区算法。主存空间的分区是在作业转入时划分的，正好划分为作业需要的大小，这样就不会产生内部碎片。但是每个分区之间可能会产生许多无法分配的空间，这就是外部碎片。</p><h5 id="可变分区算法" tabindex="-1"><a class="header-anchor" href="#可变分区算法"><span>可变分区算法</span></a></h5><p>如果现在有一个进程需要分配8KB的内存空间，那么有如下几种分区算法：</p><ol><li>首次适应法：按内存地址顺序查找，找到第一个大于等于 8KB 的空闲块，切割出 8KB 分配给进程；</li><li>最佳适应法：先给内存空闲空间的大小从小到大排序，找到第一个大于等于 8KB 的空闲块，切割出 8KB 分配给进程；</li><li>最差适应法：与最佳适应法相反，先给内存空闲空间的大小从大到小排序，找到第一个大于等于 8KB 的空闲块，切割出 8KB 分配给进程，相比于最佳适应法，可以避免产生细小的空闲块；</li><li>循环首次适应法：按首次适应法分配空间，如果后续还需要分配其他进程的内存空间，不会从头开始找，而是从当前地址往后找下一个满足大小的空闲块分配，避免每次从头查找；</li></ol><h4 id="可重定位分区" tabindex="-1"><a class="header-anchor" href="#可重定位分区"><span>可重定位分区</span></a></h4><p>可重定位分区是在分配好作业需要的内存区域后，如果后续有作业请求申请区域但是空间无法满足，那么会移动已分配好的区域，使外部碎片成为一个连续的区域，凑出来新的区域用来分配给新的作业。</p><h3 id="分页存储管理" tabindex="-1"><a class="header-anchor" href="#分页存储管理"><span>分页存储管理</span></a></h3><p>逻辑页分为页号和页内地址。</p><p>如果内存有 4GB，每页大小为 4KB，那么总共有 <code>4GB/4KB=2^20</code> 页，页号有 20 位。因为<code>4KB=2^12B</code>，所以页内地址有 12 位。</p><h4 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法"><span>页面置换算法</span></a></h4><ol><li>最优算法 OPT：理论算法，无法实现的。原理是选择未来最长时间内不被访问的页面置换，这样可以保证未来执行的都是马上要访问的。</li><li>先进先出算法 FIFO：先调入内存的页被置换淘汰，会产生抖动现象，即分配的页数越多，效率越低。</li><li>最近最少使用 LRU：过去最少使用的页面被置换淘汰，这种方式效率高，且不会被淘汰。</li><li>淘汰原则：优先淘汰最近未访问的，后淘汰最近未被修改的页面。</li></ol><h4 id="快表" tabindex="-1"><a class="header-anchor" href="#快表"><span>快表</span></a></h4><p>快表是一块小容量的相联存储器，有快速存储器组成，按内容访问，速度快，并且可以从硬件上保证按内容进行查询，一般来存放当前访问最频繁的少数活动页面的页号。</p><p>快表是将页表存于 Cache 中，慢表是将页表存于内存上。慢表需要访问两次内存才能取出页，而快表是访问一次 Cache 和一次内存，因此更快。</p><h3 id="分段存储管理" tabindex="-1"><a class="header-anchor" href="#分段存储管理"><span>分段存储管理</span></a></h3><p>将进程空间分为一个个短，每段也有段号和段内地址。每段物理大小不同，分段式根据逻辑整体分段的。段表有段长和基址两个属性，才能确定一个逻辑段在物理段中的位置。</p><p>优点：多道程序共享内存，各段程序修改互不影响；</p><p>缺点：内存利用率低，内存碎片浪费大；</p><h3 id="段页式存储管理" tabindex="-1"><a class="header-anchor" href="#段页式存储管理"><span>段页式存储管理</span></a></h3><h2 id="设备管理" tabindex="-1"><a class="header-anchor" href="#设备管理"><span>设备管理</span></a></h2><p>设备又称为外设，是计算机系统与外界交互的工具，具体负责计算机与外部的输入、输出工作。</p><p>在计算机系统中，负责管理设备和输入输出的机构称为 I/O 系统。I/O 系统由设备、控制器、通道、总线和 I/O 软件组成。</p><p>设备管理的任务是保证在并发环境下，当多个进程竞争使用设备时，按一定的策略分配和管理各种设备，控制设备的各种操作，完成 I/O 设备与主存之间的数据交互。</p><p>设备管理的主要功能是动态地掌握并记录设备的状态、设备分配和释放、缓冲区管理、实现物理 I/O 设备的操作、提供设备使用的用户接口及设备的访问和控制。</p><h3 id="设备分类" tabindex="-1"><a class="header-anchor" href="#设备分类"><span>设备分类</span></a></h3><ul><li>按数据组织分类：块设备、字符设备；</li><li>按设备功能分类：输入设备、输出设备、存储设备、网络联网设备、供电设备；</li><li>按资源分配角度分类：独占设备、共享设备和虚拟设备；</li><li>按数据传输速率分类：低速设备、中速设备、高速设备；</li></ul><h3 id="i-o软件" tabindex="-1"><a class="header-anchor" href="#i-o软件"><span>I/O软件</span></a></h3><ul><li>用户层软件：实现与用户交互的接口，用户可直接调用在用户层提供的、与 I/O 操作有关的库函数，对设备进行操作。</li><li>设备无关软件：负责实现与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</li><li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动 I/O 设备工作的驱动程序。</li><li>中断处理程序：用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理，处理完后再恢复被中断进程的现场后返回到被中断进程。</li></ul><p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/wkBBh8.png" alt="wkBBh8"></p><h2 id="文件管理" tabindex="-1"><a class="header-anchor" href="#文件管理"><span>文件管理</span></a></h2><p>文件是具有符号名的、在逻辑上具有完整意义的一组相关信息项的集合。</p><h3 id="逻辑结构" tabindex="-1"><a class="header-anchor" href="#逻辑结构"><span>逻辑结构</span></a></h3><ol><li>由结构的记录式文件</li><li>无结构的流式文件</li></ol><h3 id="物理结构" tabindex="-1"><a class="header-anchor" href="#物理结构"><span>物理结构</span></a></h3><ol><li>连续结构</li><li>链接结构</li><li>索引结构</li><li>多个物理块的索引表</li></ol><h3 id="文件目录" tabindex="-1"><a class="header-anchor" href="#文件目录"><span>文件目录</span></a></h3><h4 id="文件控制块" tabindex="-1"><a class="header-anchor" href="#文件控制块"><span>文件控制块</span></a></h4><p>文件控制块包含以下三类信息：基本信息、存取控制类信息和使用信息类</p><ol><li>基本信息：文件名、文件的物理地址、文件长度和文件块数；</li><li>存取控制类信息：文件的存取权限，像 Unix 用户分成文件拥有者、同组用户和其他用户三类，这三类的读写执行（RWX）权限；</li><li>使用信息类：文件建立日期、最后一次修改日期、最后一次访问日期、当前使用的信息（如打开文件的进程数、在文件上的等待队列）等。</li></ol><p><strong>文件控制块的有序集合称为文件目录。</strong></p><p>相对路径：从当前路径开始的路径；</p><p>绝对路径：荣根目录开始的路径；</p><p>全文件名：全文件名=绝对路径+文件名；</p><p><strong>需要注意的是，路径是不包括文件名的。</strong></p><h3 id="文件存储空间管理" tabindex="-1"><a class="header-anchor" href="#文件存储空间管理"><span>文件存储空间管理</span></a></h3><p>文件存取方式是指读写文件存储器上的一个物理块的方法，通常有顺序存取和随机存取两种方式。</p><h4 id="空闲区表" tabindex="-1"><a class="header-anchor" href="#空闲区表"><span>空闲区表</span></a></h4><h4 id="位示图" tabindex="-1"><a class="header-anchor" href="#位示图"><span>位示图</span></a></h4><h4 id="空闲块链" tabindex="-1"><a class="header-anchor" href="#空闲块链"><span>空闲块链</span></a></h4><h4 id="成组链接法" tabindex="-1"><a class="header-anchor" href="#成组链接法"><span>成组链接法</span></a></h4><h2 id="作业管理" tabindex="-1"><a class="header-anchor" href="#作业管理"><span>作业管理</span></a></h2>',124)]))}const t=n(e,[["render",p],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/note/system-architecture/operating-system/","title":"操作系统","lang":"en-US","frontmatter":{"title":"操作系统","createTime":"2022-06-02T18:53:20.000Z","permalink":"/note/system-architecture/operating-system/"},"headers":[],"readingTime":{"minutes":14.32,"words":4295},"git":{"updatedTime":1732511545000,"contributors":[{"name":"qiqiang","email":"qiqiang@pingpongx.com","commits":3,"avatar":"https://avatars.githubusercontent.com/qiqiang?v=4","url":"https://github.com/qiqiang"},{"name":"Quince","email":"qiqiangvae@foxmail.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Quince?v=4","url":"https://github.com/Quince"},{"name":"qiqiang","email":"qiqiang","commits":1,"avatar":"https://avatars.githubusercontent.com/qiqiang?v=4","url":"https://github.com/qiqiang"}]},"filePathRelative":"notes/note/系统架构师/2.操作系统.md","bulletin":false}');export{t as comp,d as data};
