import{_ as s,c as n,b as t,o as e}from"./app-C-1nbDAo.js";const l={};function m(p,a){return e(),n("div",null,a[0]||(a[0]=[t('<h2 id="cpu" tabindex="-1"><a class="header-anchor" href="#cpu"><span>CPU</span></a></h2><h3 id="运算器" tabindex="-1"><a class="header-anchor" href="#运算器"><span>运算器</span></a></h3><p>执行所有的算术运算，如加减乘除等；执行所有的逻辑运算并进行逻辑测试，如与、或、非、比较；</p><ol><li>算数逻辑单元ALU（Arithmetic Logic Unit），实现对数据的算术和逻辑运算，；</li><li>累加寄存器AC（Accumulator register），运算结果或源操作数的存放区；</li><li>数据缓冲寄存器DR（Data Register），暂时存放内存的指令或数据；</li><li>状态条件寄存器PSW（Program Status Word），保存指令运行结果的条件码内容，如溢出标志；</li></ol><h3 id="控制器" tabindex="-1"><a class="header-anchor" href="#控制器"><span>控制器</span></a></h3><p>CPU依据指令周期的不同阶段来区分二进制的指令和数据，因为在指令周期的不同阶段，指令会命令CPU去取指令或数据。</p><ol><li>程序计数器PC（Program Counter），具有寄存信息和计数两种功能，一般用来存放下一条指令在主存储器中的地址；</li><li>指令寄存器IR（Instruction Register），暂存CPU当前要执行指令；</li><li>指令译码器ID（Instruction Decoder），分析和解析操作码；</li><li>地址寄存器AR（Address Register），保存当前CPU所访问的内存地址；</li></ol><h2 id="校验码" tabindex="-1"><a class="header-anchor" href="#校验码"><span>校验码</span></a></h2><h3 id="码距" tabindex="-1"><a class="header-anchor" href="#码距"><span>码距</span></a></h3><p>码距指单个编码如A：00只需要改变一位就会变成另一个编码，那么它的码距就是1。在两个编码中，从A码变为B码所需要改变的位数成为码距。</p><p>如编码<code>00</code>变为编码<code>11</code>，其码距为 2。一半来说，码距越大，越利于纠错和检错。</p><h3 id="奇偶校验码" tabindex="-1"><a class="header-anchor" href="#奇偶校验码"><span>奇偶校验码</span></a></h3><p>如果一个编码中有奇数个 1，那么就是奇校验，反之则是偶校验。奇偶校验码的码距为 2，因为本身有一位是错误，导致校验码也错误，所以码距为 2。</p><p>奇偶校验码只能检错不能纠错。</p><h3 id="crc" tabindex="-1"><a class="header-anchor" href="#crc"><span>CRC</span></a></h3><p>原始编码为A<code>1100</code>，多项式如下</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mn>3</mn><mo>+</mo><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> G(x)=x3+x+1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>求编码A的 CRC</p><p>多项式的最高位是 3，那么 R=3，在编码A后面补 3 个 0，可以确定被除数是<code>1100000</code>。根据多项式中 x 的位数，确定除数是<code>1011</code>。将<code>1100000</code> 除以<code>1011</code>（即做异或运算）</p><img src="https://qiqiang.oss-cn-hangzhou.aliyuncs.com/muan/UdV7yk.jpg" alt="UdV7yk" style="zoom:25%;"><p>算出来之后是<code>10</code>，因为 R=3，所以需要在前面补一个 0 即<code>010</code>，那么最终的 CRC 校验码为<code>1100010</code></p><h2 id="指令系统" tabindex="-1"><a class="header-anchor" href="#指令系统"><span>指令系统</span></a></h2><p>一条计算机指令由<strong>操作码</strong>和<strong>操作数</strong>两部分组成，操作码决定要完成的操作，操作数指参加运算的数据及其所在的单元地址。</p><p>计算机执行执行的过程：取指令 -&gt; 分析指令 -&gt; 执行指令。</p><p>首先将程序计数器PC中的指令地址取出，送入地址总线，CPU 根据指令地址去内存中取出指令内容存入指令寄存器 IR，然后由指令译码器进行分析指令操作码，最后执行指令，取出指令执行所需要的源操作数。</p><h3 id="指令寻址方式" tabindex="-1"><a class="header-anchor" href="#指令寻址方式"><span>指令寻址方式</span></a></h3><ul><li>立即寻址方式：指令的地址码存在不是地址，而是操作数本身；</li><li>直接寻址方式：指令的地址码存的是操作数在主存中的地址；</li><li>间接寻址方式：指令的地址码存的是操作数的地址（饶了一次）；</li><li>寄存器寻址方式：指令的地址码存在是寄存器的编号；</li><li>基址寻址方式：</li><li>变址寻址方式：</li></ul><h3 id="指令系统类型" tabindex="-1"><a class="header-anchor" href="#指令系统类型"><span>指令系统类型</span></a></h3><table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其它</th></tr></thead><tbody><tr><td>CISC（复杂指令系统）</td><td>数量多，使用频率差别打，可变长格式</td><td>支持多种</td><td>微程序控制技术</td><td>研制周期长；以 Intel、AMD 的 x86CPU 为代码</td></tr><tr><td>RISC（精简指令系统）</td><td>数量少，使用频率接近，定长格式</td><td>支持方式少</td><td>增加了通用寄存器；硬布线逻辑控制为主，适合采用流水线</td><td>优化编译，有效支持高级语言；以 ARM 和 Power 为代表</td></tr></tbody></table><h4 id="指令流水线" tabindex="-1"><a class="header-anchor" href="#指令流水线"><span>指令流水线</span></a></h4><h5 id="指令流水线原理" tabindex="-1"><a class="header-anchor" href="#指令流水线原理"><span>指令流水线原理</span></a></h5><p>将指令分为不同的段，每段由不同的部分去处理，不同指令的取址分析和执行可以同时执行，因此可以产生叠加效果。</p><h5 id="指令流水线技术" tabindex="-1"><a class="header-anchor" href="#指令流水线技术"><span>指令流水线技术</span></a></h5><ol><li>超流水线技术：细化流水，比如一个流水线本来是3段，可以分为6段执行，以时间换空间；</li><li>超标量技术：增加硬件，以空间换时间；</li><li>超长指令字技术：通过软件，以空间换时间；</li></ol><h5 id="相关公式" tabindex="-1"><a class="header-anchor" href="#相关公式"><span>相关公式</span></a></h5><ol><li><p>流水线周期：指令分为不同执行段，其中<strong>执行段最长的时间</strong>为流水线周期；</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> m(x)=max(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>流水线执行时间：公式为：<strong>1 条指令总执行时间 + (总指令数 - 1) * 流水线周期</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>m</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> t(x,y)=g(y)+(x-1)*m(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>流水线吞吐率计算：吞吐率即单位时间内执行指令的条数，公式为<strong>指令条数 / 流水线执行时间</strong>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>t</mi></mrow><annotation encoding="application/x-tex"> r(x)=x/t </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mord">/</span><span class="mord mathnormal">t</span></span></span></span></span></p></li><li><p>流水线的加速比：公式为：<strong>不使用流水线执行时间/使用流水线执行时间</strong>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mn>3</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mn>1</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>f</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> f3(x)=f1(x)/f2(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">3</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p></li></ol><h2 id="存储系统" tabindex="-1"><a class="header-anchor" href="#存储系统"><span>存储系统</span></a></h2><p>计算机采用分级存储主要是为了解决存储容量、成本和速度之间的矛盾。</p><h3 id="高速存储-cache" tabindex="-1"><a class="header-anchor" href="#高速存储-cache"><span>高速存储 Cache</span></a></h3><p>高速存储 Cache 用来存储当前最活跃的程序和数据，容量小，直接与 CPU 交互，速度是主存的 5 -10 倍，由半导体材料构成。其内容是主存的副本拷贝。</p><p>Cache 由控制部分和存储器组成，存储器存储数据，控制部分判断 CPU 要访问的数据是否在 Cache 中，如果命中则返回，没有命中则从主存中获取。</p><p>在 CPU 工作时，送出的是主存单元地址，而应从 Cache 存储器中读写信息，此时需要将主存地址转换为 Cache 存储器地址。这种地址转换被称为地址映射，由<strong>硬件自动完成</strong>，由如下三种方式：</p><ol><li>直接映射；</li><li>全相联映射；</li><li>组相联映射（1,2组合）；</li></ol><p>三种方式按照块冲突概率从高到低排序是，1,3,2；</p><h4 id="替换算法" tabindex="-1"><a class="header-anchor" href="#替换算法"><span>替换算法</span></a></h4><ul><li>随机替换算法</li><li>先进先出算法</li><li>近期最少使用算法</li><li>优化替换算法</li></ul><h3 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理"><span>局部性原理</span></a></h3><p>空间局部性原理：相邻的地址可能会被访问，比如数组；</p><p>时间局部性原理：相近的时间内，同一个地址可能会被再次访问；</p><h3 id="磁盘" tabindex="-1"><a class="header-anchor" href="#磁盘"><span>磁盘</span></a></h3><p>磁盘有正反两个盘面，每个盘面有多个同心圆，每个同心圆是一个磁道，每个同心圆又被分为多个扇区，数据存放在扇区中。</p><p>磁盘有一个参数叫转速，指的是每秒转动的次数。磁头首先要寻找到对应的磁道，然后等待磁盘进行周期旋转，旋转到指定的扇区才能读取对应的数据。所以有如下存取时间公式：<strong>存取时间 = 寻道时间 + 等待时间</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> t(x)=f(x)+w(x) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span></p><p>寻道时间指磁头移动到磁道所需要的时间；等待时间指数据所在扇区转动到磁头下方所用的时间。</p><h4 id="磁盘调度算法" tabindex="-1"><a class="header-anchor" href="#磁盘调度算法"><span>磁盘调度算法</span></a></h4><ul><li>先来先服务 FCFS：根据进程请求访问磁盘的先手顺序进行调度；</li><li>最短寻道时间有限 SSTF：找到离当前所在磁道最近的进行调度，如果当前磁头所在磁道为 5，现在需要有 1,3,6 三个磁道需要访问，虽然 6 在最后，但是会优先调度到第 6 磁道。这种算法可能会导致 1 永远无法调度；</li><li>单项扫描调度算法 SCAN：磁头按照一个方向一直移动，直到无法移动再掉头。</li><li>扫描算法 CSCAN：扫描算法又称为电梯算法，磁头可以双向移动，磁头会选择当前磁道最近的磁道访问，按照这个方向扫描，直到没有请求才会掉头。这个调度就跟电梯类型，电梯会朝着一个方向移动，直到所有的楼层都到了才会掉头。</li></ul><h2 id="输入输出技术" tabindex="-1"><a class="header-anchor" href="#输入输出技术"><span>输入输出技术</span></a></h2><h3 id="内存与接口地址独立编址方法" tabindex="-1"><a class="header-anchor" href="#内存与接口地址独立编址方法"><span>内存与接口地址独立编址方法</span></a></h3><h3 id="内存与接口地址统一编址方法" tabindex="-1"><a class="header-anchor" href="#内存与接口地址统一编址方法"><span>内存与接口地址统一编址方法</span></a></h3><h3 id="计算机与外设数据交互方式" tabindex="-1"><a class="header-anchor" href="#计算机与外设数据交互方式"><span>计算机与外设数据交互方式</span></a></h3><ul><li>程序控制（查询）方式：CPU 主动查询外设是否完成数据传输（轮询），效率极低；</li><li>程序中断方式：外设完成数据传输之后，向 CPU 发送中断信号，等待 CPU 处理数据，此方式效率相对较高。<strong>中断响应时间</strong>指的是从发出中断请求到开始进入中断处理程序之间的耗时。<strong>中断处理时间</strong>指的是从中断处理开始到中断处理结束的耗时。<strong>中断向量</strong>提供中断服务程序的入口地址。多级中断嵌套，使用堆栈来保护断点和现场；</li><li>DMA 方式（直接存储访问）：CPU 只需要完成必要的初始化等操作，数据传输的整个过程都由 DMA 控制器来完成，在主存和外设之间建立直接的数据通道，效率很高；</li></ul><p>在一个总线周期结束之后，CPU 会响应 DMA 请求开始读取数据；CPU 响应程序中断方式请求是在一条指令执行结束时读取数据；</p><h3 id="总线" tabindex="-1"><a class="header-anchor" href="#总线"><span>总线</span></a></h3><p>总线指计算机设备和设备之间传输信息的公共数据通道，总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，因此可以将计算机系统内的多种设备连接到总线上。</p><h4 id="总线分类" tabindex="-1"><a class="header-anchor" href="#总线分类"><span>总线分类：</span></a></h4><ul><li>内部总线：内部芯片级别的总线，芯片与处理器之间的通信总线；</li><li>系统总线：是板级总线，用于计算机内各部分之间的连接，具体分为（重点考的）： <ul><li>数据总线：并行数据传输位数；</li><li>地址总线：系统可管理的内存空间大小</li><li>控制总线：传送控制命令</li></ul></li><li>外部总线：微机和外部设备的总线，如 USB；</li></ul><h4 id="单工、半双工、全双工" tabindex="-1"><a class="header-anchor" href="#单工、半双工、全双工"><span>单工、半双工、全双工</span></a></h4><ul><li>单工：数据传输只在一个方向上传输，方向是固定的，不能实现双向通信；</li><li>半双工：半双工传输方向可以切换，允许数据在两个方向上传输。但是某个时刻，只允许数据在一个方向上传输，可以基本双向通信；</li><li>全双工：全双工允许数据同时在两个方向传输，发送和接收完全独立，在发送的同时可以接收信号，或者在接收的同时可以发送。它要求发送和接收设备都要有独立的发送和接收能力；</li></ul>',68)]))}const c=s(l,[["render",m],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/note/systemArchitecture/hardware/","title":"计算机硬件","lang":"en-US","frontmatter":{"title":"计算机硬件","createTime":"2023-06-21T18:53:20.000Z","permalink":"/note/systemArchitecture/hardware/"},"headers":[],"readingTime":{"minutes":9.29,"words":2788},"git":{"updatedTime":1732511545000,"contributors":[{"name":"qiqiang","email":"qiqiang@pingpongx.com","commits":3,"avatar":"https://avatars.githubusercontent.com/qiqiang?v=4","url":"https://github.com/qiqiang"},{"name":"Quince","email":"qiqiangvae@foxmail.com","commits":4,"avatar":"https://avatars.githubusercontent.com/Quince?v=4","url":"https://github.com/Quince"},{"name":"qiqiang","email":"qiqiang","commits":1,"avatar":"https://avatars.githubusercontent.com/qiqiang?v=4","url":"https://github.com/qiqiang"}]},"filePathRelative":"notes/note/系统架构师/1.计算机硬件.md","bulletin":false}');export{c as comp,r as data};
